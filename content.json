{"pages":[],"posts":[{"title":"数据结构","text":"一，什么是数据结构？数据元素之间的关系 二，数据结构三方面 逻辑结构 （线性，非线性） 存储结构 （顺序存储，链式存储，索引存储，散列存储） 数据的运算 三，线性表具有相同数据类型的n（n &gt;= 0） 个数据元素的有限序列 顺序表逻辑上相邻的两个元素物料位置也相邻 单链表线性表的链式存储，单链表是非随机存取的存储结构，即不能直接找到表中某个特定的节点，需要从表头开始遍历","link":"/2022/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"title":"数据结构与算法","text":"一，什么是算法？对特定问题求解步骤的一种描述 二，算法的5个特征 有穷性 确定性 可行性 输入 输出 三，算法效率的度量① 时间复杂度：$$T(n) = O(f(n))$$ ② 空间复杂度：$$S(n) = O(g(n))$$ 1，Java 线性表之顺序表说明：线性表的顺序存储 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class OrderedList implements List { private final int defaultSize = 10; private int maxSize; private int size; private Object[] dataList; public OrderedList() { init(defaultSize); } public OrderedList(int size) { init(size); } @Override public int length() { return size; } @Override public Object get(int index) { return dataList[index - 1]; } @Override public boolean add(Object ele, int index) { if (index &lt; 1 || index &gt; maxSize || size == maxSize) { return false; } for (int i = size; i &gt;= index; i--) { dataList[i] = dataList[i - 1]; } dataList[index - 1] = ele; size++; return true; } @Override public boolean delete(int index) { if (index &lt; 1 || index &gt; maxSize) { return false; } for (int i = 0; i &lt; size; i++) { if ((i + 1) == index) { dataList[i] = null; } else if ((i + 1) &gt; index) { dataList[i - 1] = dataList[i]; } } dataList[size - 1] = null; size--; return true; } @Override public boolean isEmpty() { return size == 0; } private void init(int size) { this.maxSize = size; this.size = 0; this.dataList = new Object[maxSize]; }} 2，Java 线性表之链式表示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package algorithm.List;/** * @author sniper * @date 2022/3/20 18:09 * 线性表的链式表示 **/public class LinkedList { private final Node head; private Node rear; public LinkedList() { head = new Node(); rear = new Node(); } //头插法 public void headAdd(String data){ Node node = new Node(); node.data = data; node.head = head; if (head.next != null){ node.next = head.next; }else { node.next = null; } head.next = node; }// 尾插法 public void rearAdd(String data){ Node node = new Node(); node.data = data; if (head.next == null){ head.next = node; } if (rear.pre != null){ rear.pre.next = node; node.next = rear; } rear.pre = node; } private static class Node { //模拟存储数据 private String data; private Node head; private Node pre; private Node next; } } 3，Java 数组实现环形队列说明： front为列首，rear为列尾 + 1 使用取模运算是为了构成环形。当被除数小于除数时，取模返回值为被除数；当被除数等于除数时，取模返回 0 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ArrQueue { private int front; private int rear; private final int[] queue; private final int maxSize; public ArrQueue(int size) { this.queue = new int[size + 1]; this.front = 0; this.rear = 0; //由于约定一个空间不存放数据，加一使使用时传入的size为可用空间数 this.maxSize = size + 1; } public boolean isEmpty() { return rear == front; } public boolean isFull() { return (rear + 1) % maxSize == front; } public void add(int data) { if (!isFull()) { queue[rear] = data; rear = (rear + 1) % maxSize; System.out.println(&quot;保存数据，DATA：&quot; + data); return; } throw new RuntimeException(&quot;队列已满,DATA:&quot; + data); } public int getHead() { if (isEmpty()) { throw new RuntimeException(&quot;无数据&quot;); } int data = queue[front];// -1 代表无数据// queue[front] = -1; front = (front + 1) % maxSize; return data; }}","link":"/2022/03/19/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"dataStructure","slug":"dataStructure","link":"/tags/dataStructure/"},{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"}],"categories":[]}