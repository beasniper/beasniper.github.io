{"pages":[],"posts":[{"title":"数据结构与算法","text":"一，什么是算法？对特定问题求解步骤的一种描述 二，算法的5个特征 有穷性 确定性 可行性 输入 输出 三，算法效率的度量① 时间复杂度：$$T(n) = O(f(n))$$ ② 空间复杂度：$$S(n) = O(g(n))$$ 1，Java 线性表之顺序表说明：线性表的顺序存储 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768public class OrderedList implements List { private final int defaultSize = 10; private int maxSize; private int size; private Object[] dataList; public OrderedList() { init(defaultSize); } public OrderedList(int size) { init(size); } @Override public int length() { return size; } @Override public Object get(int index) { return dataList[index - 1]; } @Override public boolean add(Object ele, int index) { if (index &lt; 1 || index &gt; maxSize || size == maxSize) { return false; } for (int i = size; i &gt;= index; i--) { dataList[i] = dataList[i - 1]; } dataList[index - 1] = ele; size++; return true; } @Override public boolean delete(int index) { if (index &lt; 1 || index &gt; maxSize) { return false; } for (int i = 0; i &lt; size; i++) { if ((i + 1) == index) { dataList[i] = null; } else if ((i + 1) &gt; index) { dataList[i - 1] = dataList[i]; } } dataList[size - 1] = null; size--; return true; } @Override public boolean isEmpty() { return size == 0; } private void init(int size) { this.maxSize = size; this.size = 0; this.dataList = new Object[maxSize]; }} 2，Java 线性表之链式表示1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package algorithm.List;/** * @author sniper * @date 2022/3/20 18:09 * 线性表的链式表示 **/public class LinkedList { private final Node head; private Node rear; public LinkedList() { head = new Node(); rear = new Node(); } //头插法 public void headAdd(String data){ Node node = new Node(); node.data = data; node.head = head; if (head.next != null){ node.next = head.next; }else { node.next = null; } head.next = node; }// 尾插法 public void rearAdd(String data){ Node node = new Node(); node.data = data; if (head.next == null){ head.next = node; } if (rear.pre != null){ rear.pre.next = node; node.next = rear; } rear.pre = node; } private static class Node { //模拟存储数据 private String data; private Node head; private Node pre; private Node next; } } 3，Java 数组实现栈12345678910111213141516171819202122232425262728293031323334353637383940414243public class Stack { private int top; private final int[] stack; private final int maxSize; public Stack(int size) { this.maxSize = size; this.stack = new int[maxSize]; this.top = -1; } public void push(int ele) { if (isFull()) { throw new RuntimeException(&quot;栈满&quot;); } this.stack[++top] = ele; } public int pop() { if (isEmpty()){ throw new RuntimeException(&quot;栈空&quot;); } return this.stack[top--]; } public boolean isEmpty() { return top == -1; } public boolean isFull() { return top == maxSize - 1; } public int getTop(){ if (isEmpty()){ throw new RuntimeException(&quot;栈空&quot;); } return this.stack[top]; }} 4，Java 链表实现栈1234567891011121314151617181920212223242526272829303132333435363738public class LinkedStack { private final Node head; public LinkedStack() { this.head = new Node(); } public void push(int data) { Node node = new Node(); node.data = data; node.head = head; if (head.next != null) { node.next = head.next; } head.next = node; } public int pop() { if (isEmpty()) { throw new RuntimeException(&quot;栈空&quot;); } Node next = head.next; head.next = next.next; return next.data; } public boolean isEmpty() { return head.next == null; } private static class Node { private Node head; private int data; private Node next; }} 5，Java 数组实现环形队列说明： front为列首，rear为列尾 + 1 使用取模运算是为了构成环形。当被除数小于除数时，取模返回值为被除数；当被除数等于除数时，取模返回 0 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class ArrQueue { private int front; private int rear; private final int[] queue; private final int maxSize; public ArrQueue(int size) { this.queue = new int[size + 1]; this.front = 0; this.rear = 0; //由于约定一个空间不存放数据，加一使使用时传入的size为可用空间数 this.maxSize = size + 1; } public boolean isEmpty() { return rear == front; } public boolean isFull() { return (rear + 1) % maxSize == front; } public void add(int data) { if (!isFull()) { queue[rear] = data; rear = (rear + 1) % maxSize; System.out.println(&quot;保存数据，DATA：&quot; + data); return; } throw new RuntimeException(&quot;队列已满,DATA:&quot; + data); } public int getHead() { if (isEmpty()) { throw new RuntimeException(&quot;无数据&quot;); } int data = queue[front];// -1 代表无数据// queue[front] = -1; front = (front + 1) % maxSize; return data; }}","link":"/2022/03/19/%E7%AE%97%E6%B3%95/"},{"title":"数据结构","text":"一，什么是数据结构？数据元素之间的关系 二，数据结构三方面 逻辑结构 （线性，非线性） 存储结构 （顺序存储，链式存储，索引存储，散列存储） 数据的运算 1，线性表具有相同数据类型的n（n &gt;= 0） 个数据元素的有限序列 顺序表逻辑上相邻的两个元素物料位置也相邻 单链表线性表的链式存储，单链表是非随机存取的存储结构，即不能直接找到表中某个特定的节点，需要从表头开始遍历 栈只允许在一端进行插入或删除操作的线性表 队列一种操作受限的线性表，只允许在表的一端删除，而在表的另一端插入 2，树与二叉树树是n(n &gt;= 0) 个结点的有限集合，n = 0 时，为空树 树是一种递归的数据结构，是一种逻辑结构，同时也是一种分层结构 任一一棵非空树中应满足： 有且仅有一个特定的称为 根 的结点 当n &gt; 1时，其余结点可分为 m (m &gt; 0) 个互不相交的有限集合 T1，T2…Tm， 其中每个集合本身又是一棵树，并且称为 根 节点的子树 树的特点 树的根结点没有前驱结点，除根结点外的所有结点有且只有一个前驱结点 树中所有结点可以有零个或多个后继结点","link":"/2022/03/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"algorithm","slug":"algorithm","link":"/tags/algorithm/"},{"name":"dataStructure","slug":"dataStructure","link":"/tags/dataStructure/"}],"categories":[]}